// /*******************************************************************************
// * Copyright (C) 2019 Maxim Integrated Products, Inc., All Rights Reserved.
// *
// * Permission is hereby granted, free of charge, to any person obtaining a
// * copy of this software and associated documentation files (the "Software"),
// * to deal in the Software without restriction, including without limitation
// * the rights to use, copy, modify, merge, publish, distribute, sublicense,
// * and/or sell copies of the Software, and to permit persons to whom the
// * Software is furnished to do so, subject to the following conditions:
// *
// * The above copyright notice and this permission notice shall be included
// * in all copies or substantial portions of the Software.
// *
// * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// * IN NO EVENT SHALL MAXIM INTEGRATED BE LIABLE FOR ANY CLAIM, DAMAGES
// * OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
// * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// * OTHER DEALINGS IN THE SOFTWARE.
// *
// * Except as contained in this notice, the name of Maxim Integrated
// * Products, Inc. shall not be used except as stated in the Maxim Integrated
// * Products, Inc. Branding Policy.
// *
// * The mere transfer of this software does not imply any licenses
// * of trade secrets, proprietary technology, copyrights, patents,
// * trademarks, maskwork rights, or any other form of intellectual
// * property whatsoever. Maxim Integrated Products, Inc. retains all
// * ownership rights.
// *******************************************************************************
// */
// *********************************************************************
// @file MAX11131.h
// *********************************************************************
// Header file
// DO NOT EDIT; except areas designated "CUSTOMIZE". Automatically generated file.
// generated by XMLSystemOfDevicesToArduinoCpp.py
// System Name = ExampleSystem
// System Description = Device driver example
// Device Name = MAX11131
// Device Description = 3Msps, Low-Power, Serial SPI 12-Bit, 16-Channel, Differential/Single-Ended Input, SAR ADC
// Device DeviceBriefDescription = 12-bit 3Msps 16-ch ADC
// Device Manufacturer = Maxim Integrated
// Device PartNumber = MAX11131ATI+
// Device RegValue_Width = DataWidth16bit_HL
//
// ADC MaxOutputDataRate = 3Msps
// ADC NumChannels = 16
// ADC ResolutionBits = 12
//
// SPI CS = ActiveLow
// SPI FrameStart = CS
// SPI CPOL = 1
// SPI CPHA = 1
// SPI MOSI and MISO Data are both stable on Rising edge of SCLK
// SPI SCLK Idle High
// SPI SCLKMaxMHz = 48
// SPI SCLKMinMHz = 0.48
//


// Prevent multiple declaration
#ifndef __MAX11131_H__
#define __MAX11131_H__

// standard include for target platform -- Platform_Include_Boilerplate
#include "Arduino.h"
// SPI interface
#include "SPI.h"
// end Platform_Include_Boilerplate

//----------------------------------------
// Global setting for all channels: ADC_CONFIGURATION.REFSEL
//
// CUSTOMIZE: select one of the following options
// either by uncommenting in this file or define at the project level
//--------------------
// external single-ended reference
//~ #define REFSEL_0 	1
//
//--------------------
// external differential reference (For the 16-channel chips: channel AIN15 is unavailable, the pin is assigned to REF-.)
//~ #define REFSEL_1 	1
//
//--------------------
//
// Default settings if not defined at project level
#ifndef REFSEL_0
# ifndef REFSEL_1
#  define REFSEL_0 	1
#  define REFSEL_1 	0
# endif // REFSEL_1
#endif // REFSEL_0
//
// (optional diagnostic) pragma message the active setting
#if REFSEL_0
//~ #  pragma message("REFSEL_0: external single-ended reference")
#endif // REFSEL_0
#if REFSEL_1
//~ #  pragma message("REFSEL_1: external differential reference (For the 16-channel chips: channel AIN15 is unavailable, the pin is assigned to REF-.)")
#endif // REFSEL_1
//
// Validate the REFSEL_0 setting
#if REFSEL_0
# if REFSEL_1
#  error("cannot have both REFSEL_0 and REFSEL_1; choose one")
# endif // REFSEL_1
#endif // REFSEL_0

//----------------------------------------
// Global setting for all channels: UNIPOLAR.PDIFF_COMM
//
// CUSTOMIZE: select one of the following options
// either by uncommenting in this file or define at the project level
//--------------------
// all single-ended channels use GND as common
#define PDIFF_COMM_0 	1
//
//--------------------
// all single-ended channels are pseudo-differential with REF- as common
//~ #define PDIFF_COMM_1 	1
//
//--------------------
//
// Default settings if not defined at project level
#ifndef PDIFF_COMM_0
# ifndef PDIFF_COMM_1
#  define PDIFF_COMM_0 	1
#  define PDIFF_COMM_1 	0
# endif // PDIFF_COMM_1
#endif // PDIFF_COMM_0
//
// (optional diagnostic) pragma message the active setting
#if PDIFF_COMM_0
//~ #  pragma message("PDIFF_COMM_0: all single-ended channels use GND as common")
#endif // PDIFF_COMM_0
#if PDIFF_COMM_1
//~ #  pragma message("PDIFF_COMM_1: all single-ended channels are pseudo-differential with REF- as common")
#endif // PDIFF_COMM_1
//
// Validate the PDIFF_COMM_0 setting
#if PDIFF_COMM_0
# if PDIFF_COMM_1
#  error("cannot have both PDIFF_COMM_0 and PDIFF_COMM_1; choose one")
# endif // PDIFF_COMM_1
#endif // PDIFF_COMM_0

//----------------------------------------
// ADC Channels AIN0, AIN1
//
// CUSTOMIZE: select one of the following options
// either by uncommenting in this file or define at the project level
//--------------------
// ADC Channels AIN0, AIN1 = Differential Bipolar
// Full Scale = 2 * VREF
// Voltage per LSB count = VREF/2048
// AIN0, AIN1 are a Differential pair using Bipolar transfer function with range (+/-)Vref
// AIN0 voltage must always be between 0 and VREF.
// AIN1 voltage must always be between 0 and VREF.
//
//~ #define AIN_0_1_DifferentialBipolarFS2Vref 	1
//
//--------------------
// ADC Channels AIN0, AIN1 = Differential Bipolar
// Full Scale = VREF
// Voltage per LSB count = VREF/2048
// AIN0, AIN1 are a Differential pair using Bipolar transfer function with range (+/-)(1/2)Vref
// AIN0 voltage must always be between 0 and VREF.
// AIN1 voltage must always be between 0 and VREF.
//
//~ #define AIN_0_1_DifferentialBipolarFSVref 	1
//
//--------------------
// ADC Channels AIN0, AIN1 = Differential Unipolar (AIN0 > AIN1)
// Full Scale = VREF
// Voltage per LSB count = VREF/2048
// AIN0, AIN1 are a Differential pair using Unipolar transfer function.
// AIN0 voltage must always be between 0 and VREF.
// AIN1 voltage must always be between 0 and VREF.
//
//~ #define AIN_0_1_DifferentialUnipolar 	1
//
//--------------------
// ADC Channels AIN0, AIN1 = Both Single-Ended, Unipolar
// Full Scale = VREF
// Voltage per LSB count = VREF/2048
// AIN0 is a Single-Ended input using Unipolar transfer function.
// AIN1 is a Single-Ended input using Unipolar transfer function.
// If PDIFF_COM_1, both are Pseudo-Differential with REF- as common.
// AIN0 voltage must always be between 0 and VREF.
// AIN1 voltage must always be between 0 and VREF.
//
//~ #define AIN_0_1_SingleEnded 	1
//
//--------------------
//
// Default settings if not defined at project level
#ifndef AIN_0_1_DifferentialBipolarFS2Vref
# ifndef AIN_0_1_DifferentialBipolarFSVref
#  ifndef AIN_0_1_DifferentialUnipolar
#   ifndef AIN_0_1_SingleEnded
#    define AIN_0_1_DifferentialBipolarFS2Vref 	0
#    define AIN_0_1_DifferentialBipolarFSVref 	0
#    define AIN_0_1_DifferentialUnipolar 	0
#    define AIN_0_1_SingleEnded 	1
#   endif // AIN_0_1_SingleEnded
#  endif // AIN_0_1_DifferentialUnipolar
# endif // AIN_0_1_DifferentialBipolarFSVref
#endif // AIN_0_1_DifferentialBipolarFS2Vref
//
// (optional diagnostic) pragma message the active setting
#if AIN_0_1_DifferentialBipolarFS2Vref
//~ #  pragma message("AIN_0_1_DifferentialBipolarFS2Vref: ADC Channels AIN0, AIN1 = Differential Bipolar")
#endif // AIN_0_1_DifferentialBipolarFS2Vref
#if AIN_0_1_DifferentialBipolarFSVref
//~ #  pragma message("AIN_0_1_DifferentialBipolarFSVref: ADC Channels AIN0, AIN1 = Differential Bipolar")
#endif // AIN_0_1_DifferentialBipolarFSVref
#if AIN_0_1_DifferentialUnipolar
//~ #  pragma message("AIN_0_1_DifferentialUnipolar: ADC Channels AIN0, AIN1 = Differential Unipolar (AIN0 > AIN1)")
#endif // AIN_0_1_DifferentialUnipolar
#if AIN_0_1_SingleEnded
//~ #  pragma message("AIN_0_1_SingleEnded: ADC Channels AIN0, AIN1 = Both Single-Ended, Unipolar")
#endif // AIN_0_1_SingleEnded
//
// Validate the AIN_0_1_DifferentialBipolarFS2Vref setting
#if AIN_0_1_DifferentialBipolarFS2Vref
# if AIN_0_1_DifferentialBipolarFSVref
#  error("cannot have both AIN_0_1_DifferentialBipolarFS2Vref and AIN_0_1_DifferentialBipolarFSVref; choose one")
# endif // AIN_0_1_DifferentialBipolarFSVref
# if AIN_0_1_DifferentialUnipolar
#  error("cannot have both AIN_0_1_DifferentialBipolarFS2Vref and AIN_0_1_DifferentialUnipolar; choose one")
# endif // AIN_0_1_DifferentialUnipolar
# if AIN_0_1_SingleEnded
#  error("cannot have both AIN_0_1_DifferentialBipolarFS2Vref and AIN_0_1_SingleEnded; choose one")
# endif // AIN_0_1_SingleEnded
#endif // AIN_0_1_DifferentialBipolarFS2Vref
//
// Validate the AIN_0_1_DifferentialBipolarFSVref setting
#if AIN_0_1_DifferentialBipolarFSVref
# if AIN_0_1_DifferentialUnipolar
#  error("cannot have both AIN_0_1_DifferentialBipolarFSVref and AIN_0_1_DifferentialUnipolar; choose one")
# endif // AIN_0_1_DifferentialUnipolar
# if AIN_0_1_SingleEnded
#  error("cannot have both AIN_0_1_DifferentialBipolarFSVref and AIN_0_1_SingleEnded; choose one")
# endif // AIN_0_1_SingleEnded
#endif // AIN_0_1_DifferentialBipolarFSVref
//
// Validate the AIN_0_1_DifferentialUnipolar setting
#if AIN_0_1_DifferentialUnipolar
# if AIN_0_1_SingleEnded
#  error("cannot have both AIN_0_1_DifferentialUnipolar and AIN_0_1_SingleEnded; choose one")
# endif // AIN_0_1_SingleEnded
#endif // AIN_0_1_DifferentialUnipolar

//----------------------------------------
// ADC Channels AIN2, AIN3
//
// CUSTOMIZE: select one of the following options
// either by uncommenting in this file or define at the project level
//--------------------
// ADC Channels AIN2, AIN3 = Differential Bipolar
// Full Scale = 2 * VREF
// Voltage per LSB count = VREF/2048
// AIN2, AIN3 are a Differential pair using Bipolar transfer function with range (+/-)Vref
// AIN2 voltage must always be between 0 and VREF.
// AIN3 voltage must always be between 0 and VREF.
//
//~ #define AIN_2_3_DifferentialBipolarFS2Vref 	1
//
//--------------------
// ADC Channels AIN2, AIN3 = Differential Bipolar
// Full Scale = VREF
// Voltage per LSB count = VREF/2048
// AIN2, AIN3 are a Differential pair using Bipolar transfer function with range (+/-)(1/2)Vref
// AIN2 voltage must always be between 0 and VREF.
// AIN3 voltage must always be between 0 and VREF.
//
//~ #define AIN_2_3_DifferentialBipolarFSVref 	1
//
//--------------------
// ADC Channels AIN2, AIN3 = Differential Unipolar (AIN2 > AIN3)
// Full Scale = VREF
// Voltage per LSB count = VREF/2048
// AIN2, AIN3 are a Differential pair using Unipolar transfer function.
// AIN2 voltage must always be between 0 and VREF.
// AIN3 voltage must always be between 0 and VREF.
//
//~ #define AIN_2_3_DifferentialUnipolar 	1
//
//--------------------
// ADC Channels AIN2, AIN3 = Both Single-Ended, Unipolar
// Full Scale = VREF
// Voltage per LSB count = VREF/2048
// AIN2 is a Single-Ended input using Unipolar transfer function.
// AIN3 is a Single-Ended input using Unipolar transfer function.
// If PDIFF_COM_1, both are Pseudo-Differential with REF- as common.
// AIN2 voltage must always be between 0 and VREF.
// AIN3 voltage must always be between 0 and VREF.
//
//~ #define AIN_2_3_SingleEnded 	1
//
//--------------------
//
// Default settings if not defined at project level
#ifndef AIN_2_3_DifferentialBipolarFS2Vref
# ifndef AIN_2_3_DifferentialBipolarFSVref
#  ifndef AIN_2_3_DifferentialUnipolar
#   ifndef AIN_2_3_SingleEnded
#    define AIN_2_3_DifferentialBipolarFS2Vref 	0
#    define AIN_2_3_DifferentialBipolarFSVref 	0
#    define AIN_2_3_DifferentialUnipolar 	0
#    define AIN_2_3_SingleEnded 	1
#   endif // AIN_2_3_SingleEnded
#  endif // AIN_2_3_DifferentialUnipolar
# endif // AIN_2_3_DifferentialBipolarFSVref
#endif // AIN_2_3_DifferentialBipolarFS2Vref
//
// (optional diagnostic) pragma message the active setting
#if AIN_2_3_DifferentialBipolarFS2Vref
//~ #  pragma message("AIN_2_3_DifferentialBipolarFS2Vref: ADC Channels AIN2, AIN3 = Differential Bipolar")
#endif // AIN_2_3_DifferentialBipolarFS2Vref
#if AIN_2_3_DifferentialBipolarFSVref
//~ #  pragma message("AIN_2_3_DifferentialBipolarFSVref: ADC Channels AIN2, AIN3 = Differential Bipolar")
#endif // AIN_2_3_DifferentialBipolarFSVref
#if AIN_2_3_DifferentialUnipolar
//~ #  pragma message("AIN_2_3_DifferentialUnipolar: ADC Channels AIN2, AIN3 = Differential Unipolar (AIN2 > AIN3)")
#endif // AIN_2_3_DifferentialUnipolar
#if AIN_2_3_SingleEnded
//~ #  pragma message("AIN_2_3_SingleEnded: ADC Channels AIN2, AIN3 = Both Single-Ended, Unipolar")
#endif // AIN_2_3_SingleEnded
//
// Validate the AIN_2_3_DifferentialBipolarFS2Vref setting
#if AIN_2_3_DifferentialBipolarFS2Vref
# if AIN_2_3_DifferentialBipolarFSVref
#  error("cannot have both AIN_2_3_DifferentialBipolarFS2Vref and AIN_2_3_DifferentialBipolarFSVref; choose one")
# endif // AIN_2_3_DifferentialBipolarFSVref
# if AIN_2_3_DifferentialUnipolar
#  error("cannot have both AIN_2_3_DifferentialBipolarFS2Vref and AIN_2_3_DifferentialUnipolar; choose one")
# endif // AIN_2_3_DifferentialUnipolar
# if AIN_2_3_SingleEnded
#  error("cannot have both AIN_2_3_DifferentialBipolarFS2Vref and AIN_2_3_SingleEnded; choose one")
# endif // AIN_2_3_SingleEnded
#endif // AIN_2_3_DifferentialBipolarFS2Vref
//
// Validate the AIN_2_3_DifferentialBipolarFSVref setting
#if AIN_2_3_DifferentialBipolarFSVref
# if AIN_2_3_DifferentialUnipolar
#  error("cannot have both AIN_2_3_DifferentialBipolarFSVref and AIN_2_3_DifferentialUnipolar; choose one")
# endif // AIN_2_3_DifferentialUnipolar
# if AIN_2_3_SingleEnded
#  error("cannot have both AIN_2_3_DifferentialBipolarFSVref and AIN_2_3_SingleEnded; choose one")
# endif // AIN_2_3_SingleEnded
#endif // AIN_2_3_DifferentialBipolarFSVref
//
// Validate the AIN_2_3_DifferentialUnipolar setting
#if AIN_2_3_DifferentialUnipolar
# if AIN_2_3_SingleEnded
#  error("cannot have both AIN_2_3_DifferentialUnipolar and AIN_2_3_SingleEnded; choose one")
# endif // AIN_2_3_SingleEnded
#endif // AIN_2_3_DifferentialUnipolar

//----------------------------------------
// ADC Channels AIN4, AIN5
//
// CUSTOMIZE: select one of the following options
// either by uncommenting in this file or define at the project level
//--------------------
// ADC Channels AIN4, AIN5 = Differential Bipolar
// Full Scale = 2 * VREF
// Voltage per LSB count = VREF/2048
// AIN4, AIN5 are a Differential pair using Bipolar transfer function with range (+/-)Vref
// AIN4 voltage must always be between 0 and VREF.
// AIN5 voltage must always be between 0 and VREF.
//
//~ #define AIN_4_5_DifferentialBipolarFS2Vref 	1
//
//--------------------
// ADC Channels AIN4, AIN5 = Differential Bipolar
// Full Scale = VREF
// Voltage per LSB count = VREF/2048
// AIN4, AIN5 are a Differential pair using Bipolar transfer function with range (+/-)(1/2)Vref
// AIN4 voltage must always be between 0 and VREF.
// AIN5 voltage must always be between 0 and VREF.
//
//~ #define AIN_4_5_DifferentialBipolarFSVref 	1
//
//--------------------
// ADC Channels AIN4, AIN5 = Differential Unipolar (AIN4 > AIN5)
// Full Scale = VREF
// Voltage per LSB count = VREF/2048
// AIN4, AIN5 are a Differential pair using Unipolar transfer function.
// AIN4 voltage must always be between 0 and VREF.
// AIN5 voltage must always be between 0 and VREF.
//
//~ #define AIN_4_5_DifferentialUnipolar 	1
//
//--------------------
// ADC Channels AIN4, AIN5 = Both Single-Ended, Unipolar
// Full Scale = VREF
// Voltage per LSB count = VREF/2048
// AIN4 is a Single-Ended input using Unipolar transfer function.
// AIN5 is a Single-Ended input using Unipolar transfer function.
// If PDIFF_COM_1, both are Pseudo-Differential with REF- as common.
// AIN4 voltage must always be between 0 and VREF.
// AIN5 voltage must always be between 0 and VREF.
//
//~ #define AIN_4_5_SingleEnded 	1
//
//--------------------
//
// Default settings if not defined at project level
#ifndef AIN_4_5_DifferentialBipolarFS2Vref
# ifndef AIN_4_5_DifferentialBipolarFSVref
#  ifndef AIN_4_5_DifferentialUnipolar
#   ifndef AIN_4_5_SingleEnded
#    define AIN_4_5_DifferentialBipolarFS2Vref 	0
#    define AIN_4_5_DifferentialBipolarFSVref 	0
#    define AIN_4_5_DifferentialUnipolar 	0
#    define AIN_4_5_SingleEnded 	1
#   endif // AIN_4_5_SingleEnded
#  endif // AIN_4_5_DifferentialUnipolar
# endif // AIN_4_5_DifferentialBipolarFSVref
#endif // AIN_4_5_DifferentialBipolarFS2Vref
//
// (optional diagnostic) pragma message the active setting
#if AIN_4_5_DifferentialBipolarFS2Vref
//~ #  pragma message("AIN_4_5_DifferentialBipolarFS2Vref: ADC Channels AIN4, AIN5 = Differential Bipolar")
#endif // AIN_4_5_DifferentialBipolarFS2Vref
#if AIN_4_5_DifferentialBipolarFSVref
//~ #  pragma message("AIN_4_5_DifferentialBipolarFSVref: ADC Channels AIN4, AIN5 = Differential Bipolar")
#endif // AIN_4_5_DifferentialBipolarFSVref
#if AIN_4_5_DifferentialUnipolar
//~ #  pragma message("AIN_4_5_DifferentialUnipolar: ADC Channels AIN4, AIN5 = Differential Unipolar (AIN4 > AIN5)")
#endif // AIN_4_5_DifferentialUnipolar
#if AIN_4_5_SingleEnded
//~ #  pragma message("AIN_4_5_SingleEnded: ADC Channels AIN4, AIN5 = Both Single-Ended, Unipolar")
#endif // AIN_4_5_SingleEnded
//
// Validate the AIN_4_5_DifferentialBipolarFS2Vref setting
#if AIN_4_5_DifferentialBipolarFS2Vref
# if AIN_4_5_DifferentialBipolarFSVref
#  error("cannot have both AIN_4_5_DifferentialBipolarFS2Vref and AIN_4_5_DifferentialBipolarFSVref; choose one")
# endif // AIN_4_5_DifferentialBipolarFSVref
# if AIN_4_5_DifferentialUnipolar
#  error("cannot have both AIN_4_5_DifferentialBipolarFS2Vref and AIN_4_5_DifferentialUnipolar; choose one")
# endif // AIN_4_5_DifferentialUnipolar
# if AIN_4_5_SingleEnded
#  error("cannot have both AIN_4_5_DifferentialBipolarFS2Vref and AIN_4_5_SingleEnded; choose one")
# endif // AIN_4_5_SingleEnded
#endif // AIN_4_5_DifferentialBipolarFS2Vref
//
// Validate the AIN_4_5_DifferentialBipolarFSVref setting
#if AIN_4_5_DifferentialBipolarFSVref
# if AIN_4_5_DifferentialUnipolar
#  error("cannot have both AIN_4_5_DifferentialBipolarFSVref and AIN_4_5_DifferentialUnipolar; choose one")
# endif // AIN_4_5_DifferentialUnipolar
# if AIN_4_5_SingleEnded
#  error("cannot have both AIN_4_5_DifferentialBipolarFSVref and AIN_4_5_SingleEnded; choose one")
# endif // AIN_4_5_SingleEnded
#endif // AIN_4_5_DifferentialBipolarFSVref
//
// Validate the AIN_4_5_DifferentialUnipolar setting
#if AIN_4_5_DifferentialUnipolar
# if AIN_4_5_SingleEnded
#  error("cannot have both AIN_4_5_DifferentialUnipolar and AIN_4_5_SingleEnded; choose one")
# endif // AIN_4_5_SingleEnded
#endif // AIN_4_5_DifferentialUnipolar

//----------------------------------------
// ADC Channels AIN6, AIN7
//
// CUSTOMIZE: select one of the following options
// either by uncommenting in this file or define at the project level
//--------------------
// ADC Channels AIN6, AIN7 = Differential Bipolar
// Full Scale = 2 * VREF
// Voltage per LSB count = VREF/2048
// AIN6, AIN7 are a Differential pair using Bipolar transfer function with range (+/-)Vref
// AIN6 voltage must always be between 0 and VREF.
// AIN7 voltage must always be between 0 and VREF.
//
//~ #define AIN_6_7_DifferentialBipolarFS2Vref 	1
//
//--------------------
// ADC Channels AIN6, AIN7 = Differential Bipolar
// Full Scale = VREF
// Voltage per LSB count = VREF/2048
// AIN6, AIN7 are a Differential pair using Bipolar transfer function with range (+/-)(1/2)Vref
// AIN6 voltage must always be between 0 and VREF.
// AIN7 voltage must always be between 0 and VREF.
//
//~ #define AIN_6_7_DifferentialBipolarFSVref 	1
//
//--------------------
// ADC Channels AIN6, AIN7 = Differential Unipolar (AIN6 > AIN7)
// Full Scale = VREF
// Voltage per LSB count = VREF/2048
// AIN6, AIN7 are a Differential pair using Unipolar transfer function.
// AIN6 voltage must always be between 0 and VREF.
// AIN7 voltage must always be between 0 and VREF.
//
//~ #define AIN_6_7_DifferentialUnipolar 	1
//
//--------------------
// ADC Channels AIN6, AIN7 = Both Single-Ended, Unipolar
// Full Scale = VREF
// Voltage per LSB count = VREF/2048
// AIN6 is a Single-Ended input using Unipolar transfer function.
// AIN7 is a Single-Ended input using Unipolar transfer function.
// If PDIFF_COM_1, both are Pseudo-Differential with REF- as common.
// AIN6 voltage must always be between 0 and VREF.
// AIN7 voltage must always be between 0 and VREF.
//
//~ #define AIN_6_7_SingleEnded 	1
//
//--------------------
//
// Default settings if not defined at project level
#ifndef AIN_6_7_DifferentialBipolarFS2Vref
# ifndef AIN_6_7_DifferentialBipolarFSVref
#  ifndef AIN_6_7_DifferentialUnipolar
#   ifndef AIN_6_7_SingleEnded
#    define AIN_6_7_DifferentialBipolarFS2Vref 	0
#    define AIN_6_7_DifferentialBipolarFSVref 	0
#    define AIN_6_7_DifferentialUnipolar 	0
#    define AIN_6_7_SingleEnded 	1
#   endif // AIN_6_7_SingleEnded
#  endif // AIN_6_7_DifferentialUnipolar
# endif // AIN_6_7_DifferentialBipolarFSVref
#endif // AIN_6_7_DifferentialBipolarFS2Vref
//
// (optional diagnostic) pragma message the active setting
#if AIN_6_7_DifferentialBipolarFS2Vref
//~ #  pragma message("AIN_6_7_DifferentialBipolarFS2Vref: ADC Channels AIN6, AIN7 = Differential Bipolar")
#endif // AIN_6_7_DifferentialBipolarFS2Vref
#if AIN_6_7_DifferentialBipolarFSVref
//~ #  pragma message("AIN_6_7_DifferentialBipolarFSVref: ADC Channels AIN6, AIN7 = Differential Bipolar")
#endif // AIN_6_7_DifferentialBipolarFSVref
#if AIN_6_7_DifferentialUnipolar
//~ #  pragma message("AIN_6_7_DifferentialUnipolar: ADC Channels AIN6, AIN7 = Differential Unipolar (AIN6 > AIN7)")
#endif // AIN_6_7_DifferentialUnipolar
#if AIN_6_7_SingleEnded
//~ #  pragma message("AIN_6_7_SingleEnded: ADC Channels AIN6, AIN7 = Both Single-Ended, Unipolar")
#endif // AIN_6_7_SingleEnded
//
// Validate the AIN_6_7_DifferentialBipolarFS2Vref setting
#if AIN_6_7_DifferentialBipolarFS2Vref
# if AIN_6_7_DifferentialBipolarFSVref
#  error("cannot have both AIN_6_7_DifferentialBipolarFS2Vref and AIN_6_7_DifferentialBipolarFSVref; choose one")
# endif // AIN_6_7_DifferentialBipolarFSVref
# if AIN_6_7_DifferentialUnipolar
#  error("cannot have both AIN_6_7_DifferentialBipolarFS2Vref and AIN_6_7_DifferentialUnipolar; choose one")
# endif // AIN_6_7_DifferentialUnipolar
# if AIN_6_7_SingleEnded
#  error("cannot have both AIN_6_7_DifferentialBipolarFS2Vref and AIN_6_7_SingleEnded; choose one")
# endif // AIN_6_7_SingleEnded
#endif // AIN_6_7_DifferentialBipolarFS2Vref
//
// Validate the AIN_6_7_DifferentialBipolarFSVref setting
#if AIN_6_7_DifferentialBipolarFSVref
# if AIN_6_7_DifferentialUnipolar
#  error("cannot have both AIN_6_7_DifferentialBipolarFSVref and AIN_6_7_DifferentialUnipolar; choose one")
# endif // AIN_6_7_DifferentialUnipolar
# if AIN_6_7_SingleEnded
#  error("cannot have both AIN_6_7_DifferentialBipolarFSVref and AIN_6_7_SingleEnded; choose one")
# endif // AIN_6_7_SingleEnded
#endif // AIN_6_7_DifferentialBipolarFSVref
//
// Validate the AIN_6_7_DifferentialUnipolar setting
#if AIN_6_7_DifferentialUnipolar
# if AIN_6_7_SingleEnded
#  error("cannot have both AIN_6_7_DifferentialUnipolar and AIN_6_7_SingleEnded; choose one")
# endif // AIN_6_7_SingleEnded
#endif // AIN_6_7_DifferentialUnipolar

//----------------------------------------
// ADC Channels AIN8, AIN9
//
// CUSTOMIZE: select one of the following options
// either by uncommenting in this file or define at the project level
//--------------------
// ADC Channels AIN8, AIN9 = Differential Bipolar
// Full Scale = 2 * VREF
// Voltage per LSB count = VREF/2048
// AIN8, AIN9 are a Differential pair using Bipolar transfer function with range (+/-)Vref
// AIN8 voltage must always be between 0 and VREF.
// AIN9 voltage must always be between 0 and VREF.
//
//~ #define AIN_8_9_DifferentialBipolarFS2Vref 	1
//
//--------------------
// ADC Channels AIN8, AIN9 = Differential Bipolar
// Full Scale = VREF
// Voltage per LSB count = VREF/2048
// AIN8, AIN9 are a Differential pair using Bipolar transfer function with range (+/-)(1/2)Vref
// AIN8 voltage must always be between 0 and VREF.
// AIN9 voltage must always be between 0 and VREF.
//
//~ #define AIN_8_9_DifferentialBipolarFSVref 	1
//
//--------------------
// ADC Channels AIN8, AIN9 = Differential Unipolar (AIN8 > AIN9)
// Full Scale = VREF
// Voltage per LSB count = VREF/2048
// AIN8, AIN9 are a Differential pair using Unipolar transfer function.
// AIN8 voltage must always be between 0 and VREF.
// AIN9 voltage must always be between 0 and VREF.
//
//~ #define AIN_8_9_DifferentialUnipolar 	1
//
//--------------------
// ADC Channels AIN8, AIN9 = Both Single-Ended, Unipolar
// Full Scale = VREF
// Voltage per LSB count = VREF/2048
// AIN8 is a Single-Ended input using Unipolar transfer function.
// AIN9 is a Single-Ended input using Unipolar transfer function.
// If PDIFF_COM_1, both are Pseudo-Differential with REF- as common.
// AIN8 voltage must always be between 0 and VREF.
// AIN9 voltage must always be between 0 and VREF.
//
//~ #define AIN_8_9_SingleEnded 	1
//
//--------------------
//
// Default settings if not defined at project level
#ifndef AIN_8_9_DifferentialBipolarFS2Vref
# ifndef AIN_8_9_DifferentialBipolarFSVref
#  ifndef AIN_8_9_DifferentialUnipolar
#   ifndef AIN_8_9_SingleEnded
#    define AIN_8_9_DifferentialBipolarFS2Vref 	0
#    define AIN_8_9_DifferentialBipolarFSVref 	0
#    define AIN_8_9_DifferentialUnipolar 	0
#    define AIN_8_9_SingleEnded 	1
#   endif // AIN_8_9_SingleEnded
#  endif // AIN_8_9_DifferentialUnipolar
# endif // AIN_8_9_DifferentialBipolarFSVref
#endif // AIN_8_9_DifferentialBipolarFS2Vref
//
// (optional diagnostic) pragma message the active setting
#if AIN_8_9_DifferentialBipolarFS2Vref
//~ #  pragma message("AIN_8_9_DifferentialBipolarFS2Vref: ADC Channels AIN8, AIN9 = Differential Bipolar")
#endif // AIN_8_9_DifferentialBipolarFS2Vref
#if AIN_8_9_DifferentialBipolarFSVref
//~ #  pragma message("AIN_8_9_DifferentialBipolarFSVref: ADC Channels AIN8, AIN9 = Differential Bipolar")
#endif // AIN_8_9_DifferentialBipolarFSVref
#if AIN_8_9_DifferentialUnipolar
//~ #  pragma message("AIN_8_9_DifferentialUnipolar: ADC Channels AIN8, AIN9 = Differential Unipolar (AIN8 > AIN9)")
#endif // AIN_8_9_DifferentialUnipolar
#if AIN_8_9_SingleEnded
//~ #  pragma message("AIN_8_9_SingleEnded: ADC Channels AIN8, AIN9 = Both Single-Ended, Unipolar")
#endif // AIN_8_9_SingleEnded
//
// Validate the AIN_8_9_DifferentialBipolarFS2Vref setting
#if AIN_8_9_DifferentialBipolarFS2Vref
# if AIN_8_9_DifferentialBipolarFSVref
#  error("cannot have both AIN_8_9_DifferentialBipolarFS2Vref and AIN_8_9_DifferentialBipolarFSVref; choose one")
# endif // AIN_8_9_DifferentialBipolarFSVref
# if AIN_8_9_DifferentialUnipolar
#  error("cannot have both AIN_8_9_DifferentialBipolarFS2Vref and AIN_8_9_DifferentialUnipolar; choose one")
# endif // AIN_8_9_DifferentialUnipolar
# if AIN_8_9_SingleEnded
#  error("cannot have both AIN_8_9_DifferentialBipolarFS2Vref and AIN_8_9_SingleEnded; choose one")
# endif // AIN_8_9_SingleEnded
#endif // AIN_8_9_DifferentialBipolarFS2Vref
//
// Validate the AIN_8_9_DifferentialBipolarFSVref setting
#if AIN_8_9_DifferentialBipolarFSVref
# if AIN_8_9_DifferentialUnipolar
#  error("cannot have both AIN_8_9_DifferentialBipolarFSVref and AIN_8_9_DifferentialUnipolar; choose one")
# endif // AIN_8_9_DifferentialUnipolar
# if AIN_8_9_SingleEnded
#  error("cannot have both AIN_8_9_DifferentialBipolarFSVref and AIN_8_9_SingleEnded; choose one")
# endif // AIN_8_9_SingleEnded
#endif // AIN_8_9_DifferentialBipolarFSVref
//
// Validate the AIN_8_9_DifferentialUnipolar setting
#if AIN_8_9_DifferentialUnipolar
# if AIN_8_9_SingleEnded
#  error("cannot have both AIN_8_9_DifferentialUnipolar and AIN_8_9_SingleEnded; choose one")
# endif // AIN_8_9_SingleEnded
#endif // AIN_8_9_DifferentialUnipolar

//----------------------------------------
// ADC Channels AIN10, AIN11
//
// CUSTOMIZE: select one of the following options
// either by uncommenting in this file or define at the project level
//--------------------
// ADC Channels AIN10, AIN11 = Differential Bipolar
// Full Scale = 2 * VREF
// Voltage per LSB count = VREF/2048
// AIN10, AIN11 are a Differential pair using Bipolar transfer function with range (+/-)Vref
// AIN10 voltage must always be between 0 and VREF.
// AIN11 voltage must always be between 0 and VREF.
//
//~ #define AIN_10_11_DifferentialBipolarFS2Vref 	1
//
//--------------------
// ADC Channels AIN10, AIN11 = Differential Bipolar
// Full Scale = VREF
// Voltage per LSB count = VREF/2048
// AIN10, AIN11 are a Differential pair using Bipolar transfer function with range (+/-)(1/2)Vref
// AIN10 voltage must always be between 0 and VREF.
// AIN11 voltage must always be between 0 and VREF.
//
//~ #define AIN_10_11_DifferentialBipolarFSVref 	1
//
//--------------------
// ADC Channels AIN10, AIN11 = Differential Unipolar (AIN10 > AIN11)
// Full Scale = VREF
// Voltage per LSB count = VREF/2048
// AIN10, AIN11 are a Differential pair using Unipolar transfer function.
// AIN10 voltage must always be between 0 and VREF.
// AIN11 voltage must always be between 0 and VREF.
//
//~ #define AIN_10_11_DifferentialUnipolar 	1
//
//--------------------
// ADC Channels AIN10, AIN11 = Both Single-Ended, Unipolar
// Full Scale = VREF
// Voltage per LSB count = VREF/2048
// AIN10 is a Single-Ended input using Unipolar transfer function.
// AIN11 is a Single-Ended input using Unipolar transfer function.
// If PDIFF_COM_1, both are Pseudo-Differential with REF- as common.
// AIN10 voltage must always be between 0 and VREF.
// AIN11 voltage must always be between 0 and VREF.
//
//~ #define AIN_10_11_SingleEnded 	1
//
//--------------------
//
// Default settings if not defined at project level
#ifndef AIN_10_11_DifferentialBipolarFS2Vref
# ifndef AIN_10_11_DifferentialBipolarFSVref
#  ifndef AIN_10_11_DifferentialUnipolar
#   ifndef AIN_10_11_SingleEnded
#    define AIN_10_11_DifferentialBipolarFS2Vref 	0
#    define AIN_10_11_DifferentialBipolarFSVref 	0
#    define AIN_10_11_DifferentialUnipolar 	0
#    define AIN_10_11_SingleEnded 	1
#   endif // AIN_10_11_SingleEnded
#  endif // AIN_10_11_DifferentialUnipolar
# endif // AIN_10_11_DifferentialBipolarFSVref
#endif // AIN_10_11_DifferentialBipolarFS2Vref
//
// (optional diagnostic) pragma message the active setting
#if AIN_10_11_DifferentialBipolarFS2Vref
//~ #  pragma message("AIN_10_11_DifferentialBipolarFS2Vref: ADC Channels AIN10, AIN11 = Differential Bipolar")
#endif // AIN_10_11_DifferentialBipolarFS2Vref
#if AIN_10_11_DifferentialBipolarFSVref
//~ #  pragma message("AIN_10_11_DifferentialBipolarFSVref: ADC Channels AIN10, AIN11 = Differential Bipolar")
#endif // AIN_10_11_DifferentialBipolarFSVref
#if AIN_10_11_DifferentialUnipolar
//~ #  pragma message("AIN_10_11_DifferentialUnipolar: ADC Channels AIN10, AIN11 = Differential Unipolar (AIN10 > AIN11)")
#endif // AIN_10_11_DifferentialUnipolar
#if AIN_10_11_SingleEnded
//~ #  pragma message("AIN_10_11_SingleEnded: ADC Channels AIN10, AIN11 = Both Single-Ended, Unipolar")
#endif // AIN_10_11_SingleEnded
//
// Validate the AIN_10_11_DifferentialBipolarFS2Vref setting
#if AIN_10_11_DifferentialBipolarFS2Vref
# if AIN_10_11_DifferentialBipolarFSVref
#  error("cannot have both AIN_10_11_DifferentialBipolarFS2Vref and AIN_10_11_DifferentialBipolarFSVref; choose one")
# endif // AIN_10_11_DifferentialBipolarFSVref
# if AIN_10_11_DifferentialUnipolar
#  error("cannot have both AIN_10_11_DifferentialBipolarFS2Vref and AIN_10_11_DifferentialUnipolar; choose one")
# endif // AIN_10_11_DifferentialUnipolar
# if AIN_10_11_SingleEnded
#  error("cannot have both AIN_10_11_DifferentialBipolarFS2Vref and AIN_10_11_SingleEnded; choose one")
# endif // AIN_10_11_SingleEnded
#endif // AIN_10_11_DifferentialBipolarFS2Vref
//
// Validate the AIN_10_11_DifferentialBipolarFSVref setting
#if AIN_10_11_DifferentialBipolarFSVref
# if AIN_10_11_DifferentialUnipolar
#  error("cannot have both AIN_10_11_DifferentialBipolarFSVref and AIN_10_11_DifferentialUnipolar; choose one")
# endif // AIN_10_11_DifferentialUnipolar
# if AIN_10_11_SingleEnded
#  error("cannot have both AIN_10_11_DifferentialBipolarFSVref and AIN_10_11_SingleEnded; choose one")
# endif // AIN_10_11_SingleEnded
#endif // AIN_10_11_DifferentialBipolarFSVref
//
// Validate the AIN_10_11_DifferentialUnipolar setting
#if AIN_10_11_DifferentialUnipolar
# if AIN_10_11_SingleEnded
#  error("cannot have both AIN_10_11_DifferentialUnipolar and AIN_10_11_SingleEnded; choose one")
# endif // AIN_10_11_SingleEnded
#endif // AIN_10_11_DifferentialUnipolar

//----------------------------------------
// ADC Channels AIN12, AIN13
//
// CUSTOMIZE: select one of the following options
// either by uncommenting in this file or define at the project level
//--------------------
// ADC Channels AIN12, AIN13 = Differential Bipolar
// Full Scale = 2 * VREF
// Voltage per LSB count = VREF/2048
// AIN12, AIN13 are a Differential pair using Bipolar transfer function with range (+/-)Vref
// AIN12 voltage must always be between 0 and VREF.
// AIN13 voltage must always be between 0 and VREF.
//
//~ #define AIN_12_13_DifferentialBipolarFS2Vref 	1
//
//--------------------
// ADC Channels AIN12, AIN13 = Differential Bipolar
// Full Scale = VREF
// Voltage per LSB count = VREF/2048
// AIN12, AIN13 are a Differential pair using Bipolar transfer function with range (+/-)(1/2)Vref
// AIN12 voltage must always be between 0 and VREF.
// AIN13 voltage must always be between 0 and VREF.
//
//~ #define AIN_12_13_DifferentialBipolarFSVref 	1
//
//--------------------
// ADC Channels AIN12, AIN13 = Differential Unipolar (AIN12 > AIN13)
// Full Scale = VREF
// Voltage per LSB count = VREF/2048
// AIN12, AIN13 are a Differential pair using Unipolar transfer function.
// AIN12 voltage must always be between 0 and VREF.
// AIN13 voltage must always be between 0 and VREF.
//
//~ #define AIN_12_13_DifferentialUnipolar 	1
//
//--------------------
// ADC Channels AIN12, AIN13 = Both Single-Ended, Unipolar
// Full Scale = VREF
// Voltage per LSB count = VREF/2048
// AIN12 is a Single-Ended input using Unipolar transfer function.
// AIN13 is a Single-Ended input using Unipolar transfer function.
// If PDIFF_COM_1, both are Pseudo-Differential with REF- as common.
// AIN12 voltage must always be between 0 and VREF.
// AIN13 voltage must always be between 0 and VREF.
//
//~ #define AIN_12_13_SingleEnded 	1
//
//--------------------
//
// Default settings if not defined at project level
#ifndef AIN_12_13_DifferentialBipolarFS2Vref
# ifndef AIN_12_13_DifferentialBipolarFSVref
#  ifndef AIN_12_13_DifferentialUnipolar
#   ifndef AIN_12_13_SingleEnded
#    define AIN_12_13_DifferentialBipolarFS2Vref 	0
#    define AIN_12_13_DifferentialBipolarFSVref 	0
#    define AIN_12_13_DifferentialUnipolar 	0
#    define AIN_12_13_SingleEnded 	1
#   endif // AIN_12_13_SingleEnded
#  endif // AIN_12_13_DifferentialUnipolar
# endif // AIN_12_13_DifferentialBipolarFSVref
#endif // AIN_12_13_DifferentialBipolarFS2Vref
//
// (optional diagnostic) pragma message the active setting
#if AIN_12_13_DifferentialBipolarFS2Vref
//~ #  pragma message("AIN_12_13_DifferentialBipolarFS2Vref: ADC Channels AIN12, AIN13 = Differential Bipolar")
#endif // AIN_12_13_DifferentialBipolarFS2Vref
#if AIN_12_13_DifferentialBipolarFSVref
//~ #  pragma message("AIN_12_13_DifferentialBipolarFSVref: ADC Channels AIN12, AIN13 = Differential Bipolar")
#endif // AIN_12_13_DifferentialBipolarFSVref
#if AIN_12_13_DifferentialUnipolar
//~ #  pragma message("AIN_12_13_DifferentialUnipolar: ADC Channels AIN12, AIN13 = Differential Unipolar (AIN12 > AIN13)")
#endif // AIN_12_13_DifferentialUnipolar
#if AIN_12_13_SingleEnded
//~ #  pragma message("AIN_12_13_SingleEnded: ADC Channels AIN12, AIN13 = Both Single-Ended, Unipolar")
#endif // AIN_12_13_SingleEnded
//
// Validate the AIN_12_13_DifferentialBipolarFS2Vref setting
#if AIN_12_13_DifferentialBipolarFS2Vref
# if AIN_12_13_DifferentialBipolarFSVref
#  error("cannot have both AIN_12_13_DifferentialBipolarFS2Vref and AIN_12_13_DifferentialBipolarFSVref; choose one")
# endif // AIN_12_13_DifferentialBipolarFSVref
# if AIN_12_13_DifferentialUnipolar
#  error("cannot have both AIN_12_13_DifferentialBipolarFS2Vref and AIN_12_13_DifferentialUnipolar; choose one")
# endif // AIN_12_13_DifferentialUnipolar
# if AIN_12_13_SingleEnded
#  error("cannot have both AIN_12_13_DifferentialBipolarFS2Vref and AIN_12_13_SingleEnded; choose one")
# endif // AIN_12_13_SingleEnded
#endif // AIN_12_13_DifferentialBipolarFS2Vref
//
// Validate the AIN_12_13_DifferentialBipolarFSVref setting
#if AIN_12_13_DifferentialBipolarFSVref
# if AIN_12_13_DifferentialUnipolar
#  error("cannot have both AIN_12_13_DifferentialBipolarFSVref and AIN_12_13_DifferentialUnipolar; choose one")
# endif // AIN_12_13_DifferentialUnipolar
# if AIN_12_13_SingleEnded
#  error("cannot have both AIN_12_13_DifferentialBipolarFSVref and AIN_12_13_SingleEnded; choose one")
# endif // AIN_12_13_SingleEnded
#endif // AIN_12_13_DifferentialBipolarFSVref
//
// Validate the AIN_12_13_DifferentialUnipolar setting
#if AIN_12_13_DifferentialUnipolar
# if AIN_12_13_SingleEnded
#  error("cannot have both AIN_12_13_DifferentialUnipolar and AIN_12_13_SingleEnded; choose one")
# endif // AIN_12_13_SingleEnded
#endif // AIN_12_13_DifferentialUnipolar

//----------------------------------------
// ADC Channels AIN14, AIN15
//
// CUSTOMIZE: select one of the following options
// either by uncommenting in this file or define at the project level
//--------------------
// ADC Channels AIN14, AIN15 = Differential Bipolar
// Full Scale = 2 * VREF
// Voltage per LSB count = VREF/2048
// AIN14, AIN15 are a Differential pair using Bipolar transfer function with range (+/-)Vref
// AIN14 voltage must always be between 0 and VREF.
// AIN15 voltage must always be between 0 and VREF.
//
//~ #define AIN_14_15_DifferentialBipolarFS2Vref 	1
//
//--------------------
// ADC Channels AIN14, AIN15 = Differential Bipolar
// Full Scale = VREF
// Voltage per LSB count = VREF/2048
// AIN14, AIN15 are a Differential pair using Bipolar transfer function with range (+/-)(1/2)Vref
// AIN14 voltage must always be between 0 and VREF.
// AIN15 voltage must always be between 0 and VREF.
//
//~ #define AIN_14_15_DifferentialBipolarFSVref 	1
//
//--------------------
// ADC Channels AIN14, AIN15 = Differential Unipolar (AIN14 > AIN15)
// Full Scale = VREF
// Voltage per LSB count = VREF/2048
// AIN14, AIN15 are a Differential pair using Unipolar transfer function.
// AIN14 voltage must always be between 0 and VREF.
// AIN15 voltage must always be between 0 and VREF.
//
//~ #define AIN_14_15_DifferentialUnipolar 	1
//
//--------------------
// ADC Channels AIN14, AIN15 = Both Single-Ended, Unipolar
// Full Scale = VREF
// Voltage per LSB count = VREF/2048
// AIN14 is a Single-Ended input using Unipolar transfer function.
// AIN15 is a Single-Ended input using Unipolar transfer function.
// If PDIFF_COM_1, both are Pseudo-Differential with REF- as common.
// AIN14 voltage must always be between 0 and VREF.
// AIN15 voltage must always be between 0 and VREF.
//
//~ #define AIN_14_15_SingleEnded 	1
//
//--------------------
//
// Default settings if not defined at project level
#ifndef AIN_14_15_DifferentialBipolarFS2Vref
# ifndef AIN_14_15_DifferentialBipolarFSVref
#  ifndef AIN_14_15_DifferentialUnipolar
#   ifndef AIN_14_15_SingleEnded
#    define AIN_14_15_DifferentialBipolarFS2Vref 	0
#    define AIN_14_15_DifferentialBipolarFSVref 	0
#    define AIN_14_15_DifferentialUnipolar 	0
#    define AIN_14_15_SingleEnded 	1
#   endif // AIN_14_15_SingleEnded
#  endif // AIN_14_15_DifferentialUnipolar
# endif // AIN_14_15_DifferentialBipolarFSVref
#endif // AIN_14_15_DifferentialBipolarFS2Vref
//
// (optional diagnostic) pragma message the active setting
#if AIN_14_15_DifferentialBipolarFS2Vref
//~ #  pragma message("AIN_14_15_DifferentialBipolarFS2Vref: ADC Channels AIN14, AIN15 = Differential Bipolar")
#endif // AIN_14_15_DifferentialBipolarFS2Vref
#if AIN_14_15_DifferentialBipolarFSVref
//~ #  pragma message("AIN_14_15_DifferentialBipolarFSVref: ADC Channels AIN14, AIN15 = Differential Bipolar")
#endif // AIN_14_15_DifferentialBipolarFSVref
#if AIN_14_15_DifferentialUnipolar
//~ #  pragma message("AIN_14_15_DifferentialUnipolar: ADC Channels AIN14, AIN15 = Differential Unipolar (AIN14 > AIN15)")
#endif // AIN_14_15_DifferentialUnipolar
#if AIN_14_15_SingleEnded
//~ #  pragma message("AIN_14_15_SingleEnded: ADC Channels AIN14, AIN15 = Both Single-Ended, Unipolar")
#endif // AIN_14_15_SingleEnded
//
// Validate the AIN_14_15_DifferentialBipolarFS2Vref setting
#if AIN_14_15_DifferentialBipolarFS2Vref
# if AIN_14_15_DifferentialBipolarFSVref
#  error("cannot have both AIN_14_15_DifferentialBipolarFS2Vref and AIN_14_15_DifferentialBipolarFSVref; choose one")
# endif // AIN_14_15_DifferentialBipolarFSVref
# if AIN_14_15_DifferentialUnipolar
#  error("cannot have both AIN_14_15_DifferentialBipolarFS2Vref and AIN_14_15_DifferentialUnipolar; choose one")
# endif // AIN_14_15_DifferentialUnipolar
# if AIN_14_15_SingleEnded
#  error("cannot have both AIN_14_15_DifferentialBipolarFS2Vref and AIN_14_15_SingleEnded; choose one")
# endif // AIN_14_15_SingleEnded
#endif // AIN_14_15_DifferentialBipolarFS2Vref
//
// Validate the AIN_14_15_DifferentialBipolarFSVref setting
#if AIN_14_15_DifferentialBipolarFSVref
# if AIN_14_15_DifferentialUnipolar
#  error("cannot have both AIN_14_15_DifferentialBipolarFSVref and AIN_14_15_DifferentialUnipolar; choose one")
# endif // AIN_14_15_DifferentialUnipolar
# if AIN_14_15_SingleEnded
#  error("cannot have both AIN_14_15_DifferentialBipolarFSVref and AIN_14_15_SingleEnded; choose one")
# endif // AIN_14_15_SingleEnded
#endif // AIN_14_15_DifferentialBipolarFSVref
//
// Validate the AIN_14_15_DifferentialUnipolar setting
#if AIN_14_15_DifferentialUnipolar
# if AIN_14_15_SingleEnded
#  error("cannot have both AIN_14_15_DifferentialUnipolar and AIN_14_15_SingleEnded; choose one")
# endif // AIN_14_15_SingleEnded
#endif // AIN_14_15_DifferentialUnipolar

/**
 * @brief MAX11131 3Msps, Low-Power, Serial SPI 12-Bit, 16-Channel, Differential/Single-Ended Input, SAR ADC
 *
 *
 *
 * Datasheet: https://www.maximintegrated.com/MAX11131
 *
 *
 *
 * @code
 * // example code includes
 * // standard include for target platform -- Platform_Include_Boilerplate
 * #include "Arduino.h"
 * // SPI interface
 * #include "SPI.h"
 * // end Platform_Include_Boilerplate
 * #include "MAX11131.h"
 *
 * // example code declare SPI interface
 * // global SPI uses conventional Arduino 10-pin header D11 D12 D13
 * // chip select is on Arduino 10-pin header D10
 * uint8_t spi_cs = 10; // Generic: Arduino 10-pin header D10
 *
 * // example code declare GPIO interface pins
 * uint8_t CNVST_pin = 9; // Digital Trigger Input to MAX11131 device
 * // uint8_t REF_plus_pin = Px_x_PortName_To_Be_Determined; // Reference Input to MAX11131 device
 * // uint8_t REF_minus_slash_AIN15_pin = Px_x_PortName_To_Be_Determined; // Reference Input to MAX11131 device
 * uint8_t EOC_pin = 2; // Digital Event Output from MAX11131 device
 * // example code declare device instance
 * MAX11131 g_MAX11131_device(spi_cs, CNVST_pin, EOC_pin, MAX11131::MAX11131_IC);
 *
 * // example code main function
 * int main()
 * {
 *     // example code: serial port banner message
 *     Serial.begin(9600); // serial baud rate
 *     Serial.print("MAX11131\r\n");
 *
 *     g_MAX11131_device.Init();
 *
 *     while(1) { // this code repeats forever
 *         // this code repeats forever
 *         // Measure ADC channels in sequence from AIN0 to channelNumber_0_15.
 *         // @param[in] g_MAX11131_device.channelNumber_0_15: AIN Channel Number
 *         // @param[in] g_MAX11131_device.PowerManagement_0_2: 0=Normal, 1=AutoShutdown, 2=AutoStandby
 *         // @param[in] g_MAX11131_device.chan_id_0_1: ADC_MODE_CONTROL.CHAN_ID
 *         int channelId_0_15 = 15;
 *         g_MAX11131_device.channelNumber_0_15 = channelId_0_15;
 *         g_MAX11131_device.PowerManagement_0_2 = 0;
 *         g_MAX11131_device.chan_id_0_1 = 1;
 *         g_MAX11131_device.NumWords = g_MAX11131_device.ScanStandardExternalClock();
 *
 *         // Read raw ADC codes from device into AINcode[] and RAW_misoData16[]
 *         // @pre one of the MAX11311_Scan functions was called, setting g_MAX11131_device.NumWords
 *         g_MAX11131_device.ReadAINcode();
 *         // @post RAW_misoData16[index] contains the raw SPI Master-In,Slave-Out data
 *         // @post AINcode[NUM_CHANNELS] contains the latest readings in LSBs
 *
 *         //wait(1.0);
 *         // Use Arduino Serial Plotter to view output: Tools | Serial Plotter
 *         Serial.print(g_MAX11131_device.AINcode[0]);
 *         for (int index = 1; index <= channelId_0_15; index++) {
 *             Serial.print(",");
 *             Serial.print(g_MAX11131_device.AINcode[index]);
 *         }
 *         Serial.println();
 *     } // this code repeats forever
 * }
 * @endcode
 */
class MAX11131 {
public:
    //----------------------------------------
    /// ADC_MODE_CONTROL.SCAN[3:0] ADC Scan Control (command)
    typedef enum MAX11131_SCAN_enum_t {
        SCAN_0000_NOP = 0x00, //!< 8'b00000000
        SCAN_0001_Manual = 0x01, //!< 8'b00000001
        SCAN_0010_Repeat = 0x02, //!< 8'b00000010
        SCAN_0011_StandardInternalClock = 0x03, //!< 8'b00000011
        SCAN_0100_StandardExternalClock = 0x04, //!< 8'b00000100
        SCAN_0101_UpperInternalClock = 0x05, //!< 8'b00000101
        SCAN_0110_UpperExternalClock = 0x06, //!< 8'b00000110
        SCAN_0111_CustomInternalClock = 0x07, //!< 8'b00000111
        SCAN_1000_CustomExternalClock = 0x08, //!< 8'b00001000
        SCAN_1001_SampleSetExternalClock = 0x09, //!< 8'b00001001
    } MAX11131_SCAN_enum_t;

    //----------------------------------------
    /// ADC_MODE_CONTROL.RESET[1:0] Reset 0=Normal 1=ResetFIFO 2=ResetAllRegisters 3=reserved
    typedef enum MAX11131_RESET_enum_t {
        RESET_00_Normal = 0x00, //!< 8'b00000000
        RESET_01_ResetFIFO = 0x01, //!< 8'b00000001
        RESET_10_ResetAllRegisters = 0x02, //!< 8'b00000010
    } MAX11131_RESET_enum_t;

    //----------------------------------------
    /// ADC_MODE_CONTROL.PM[1:0] Power Management 0=Normal, 1=AutoShutdown, 2=AutoStandby 3=reserved
    typedef enum MAX11131_PM_enum_t {
        PM_00_Normal = 0x00, //!< 8'b00000000
        PM_01_AutoShutdown = 0x01, //!< 8'b00000001
        PM_10_AutoStandby = 0x02, //!< 8'b00000010
    } MAX11131_PM_enum_t;

    /**
     * @brief IC's supported with this driver
     * @details MAX11131
     */
    typedef enum
    {
        MAX11131_IC = 0,
        //MAX11131_IC = 1
    } MAX11131_ic_t;

    /**********************************************************//**
    * @brief Constructor for MAX11131 Class.
    *
    *
    * On Entry:
    *     @param[in] spi_cs_pin - digital output pin for device SPI chip select
    *     @param[in] CNVST_pin - digital output pin
    *     @param[in] EOC_pin - digital input pin
    *     @param[in] ic_variant - which type of MAX11131 is used
    *
    * On Exit:
    *
    * @return None
    **************************************************************/
    MAX11131(uint8_t spi_cs_pin, // SPI interface
            uint8_t CNVST_pin, // Digital Trigger Input to MAX11131 device
            // uint8_t REF_plus_pin, // Reference Input to MAX11131 device
            // uint8_t REF_minus_slash_AIN15_pin, // Reference Input to MAX11131 device
            uint8_t EOC_pin, // Digital Event Output from MAX11131 device
            MAX11131_ic_t ic_variant);

    /************************************************************
     * @brief Default destructor for MAX11131 Class.
     *
     * @details Destroys SPI object if owner
     *
     * On Entry:
     *
     * On Exit:
     *
     * @return None
     **************************************************************/
    ~MAX11131();

    /// Function pointer void f(size_t byteCount, uint8_t mosiData[], uint8_t misoData[])
    /// equivalent to mbed Callback<void(size_t, uint8_t*, uint8_t*)>
    typedef void (*Callback_onSPI)(size_t byteCount, uint8_t mosiData[], uint8_t misoData[]);
    Callback_onSPI onSPIprint; //!< optional @ref onSPIprint SPI diagnostic function

    /// set SPI SCLK frequency
    void spi_frequency(uint32_t spi_sclk_Hz);

//----------------------------------------
public:

    /// shadow of write-only register ADC_MODE_CONTROL
    /// mosiData16 0x0000..0x7FFF format: 0 SCAN[3:0] CHSEL[3:0] RESET[1:0] PM[1:0] CHAN_ID SWCNV 0
    int16_t ADC_MODE_CONTROL;

    /// shadow of write-only register ADC_CONFIGURATION
    /// mosiData16 0x8000..0x87FF format: 1 0 0 0 0 REFSEL AVGON NAVG[1:0] NSCAN[1:0] SPM[1:0] ECHO 0 0
    int16_t ADC_CONFIGURATION;

    /// shadow of write-only register UNIPOLAR
    /// mosiData16 0x8800..0x8FFF format: 1 0 0 0 1 UCH0/1 UCH2/3 UCH4/5 UCH6/7 UCH8/9 UCH10/11 UCH12/13 UCH14/15 PDIFF_COM x x
    int16_t UNIPOLAR;

    /// shadow of write-only register BIPOLAR
    /// mosiData16 0x9000..0x97FF format: 1 0 0 1 0 BCH0/1 BCH2/3 BCH4/5 BCH6/7 BCH8/9 BCH10/11 BCH12/13 BCH14/15 x x x
    int16_t BIPOLAR;

    /// shadow of write-only register RANGE
    /// mosiData16 0x9800..0x9FFF format: 1 0 0 1 1 RANGE0/1 RANGE2/3 RANGE4/5 RANGE6/7 RANGE8/9 RANGE10/11 RANGE12/13 RANGE14/15 x x x
    int16_t RANGE;

    /// shadow of write-only register CSCAN0
    /// mosiData16 0xA000..0xA7FF format: 1 0 1 0 0 CHSCAN15 CHSCAN14 CHSCAN13 CHSCAN12 CHSCAN11 CHSCAN10 CHSCAN9 CHSCAN8 x x x
    int16_t CSCAN0;

    /// shadow of write-only register CSCAN1
    /// mosiData16 0xA800..0xAFFF format: 1 0 1 0 1 CHSCAN7 CHSCAN6 CHSCAN5 CHSCAN4 CHSCAN3 CHSCAN2 CHSCAN1 CHSCAN0 x x x
    int16_t CSCAN1;

    /// shadow of write-only register SAMPLESET
    /// mosiData16 0xB000..0xB7FF format: 1 0 1 1 0 SEQ_LENGTH[7:0] x x x followed by enabledChannelsPattern.
    /// NOTE: Send the sampleset pattern, with 4 entries packed into each 16-bit SPI word. Pad unused entries with 0.
    /// NOTE: Keep CS low during the entire enabledChannelsPattern entry.
    int16_t SAMPLESET;

    /// unpacked SAMPLESET.SEQ_LENGTH[7:0] determines length of pattern
    /// NOTE: SAMPLESET.SEQ_LENGTH[7:0] is the number of channel entries in the pattern.
    /// NOTE: Each channel entry is 4 bits. The first 4 bits are the first channel in the sequence.
    /// NOTE: Channels can be repeated in any arbitrary order.
    /// NOTE: The channel entry pattern is sent immediately after writing SAMPLESET.
    uint8_t enabledChannelsPatternLength_1_256;

    /// unpacked shadow of write-only register SAMPLESET enabledChannelsPattern.
    /// Array Length = enabledChannelsPatternLength_1_256.
    /// Each entry is a channel number between 0 and 15.
    uint8_t enabledChannelsPattern[256];

    /// Diagnostic: what is the meaning of SPI Master Out data.
    /// 0:Nothing 1:regWrite 2:sampleSetPattern
    uint8_t SPI_MOSI_Semantic;

    /// number of ScanRead() words needed to retrieve all measurements.
    uint16_t NumWords;

    /// Is the currently configured mode external or internal clock. 1:External Clock 0:Internal Clock
    uint8_t isExternalClock;

    /// unpacked ADC_MODE_CONTROL.SCAN[3:0] Scan Mode MAX11131_SCAN_enum_t
    uint8_t ScanMode;

    /// unpacked ADC_MODE_CONTROL.CHSEL[3:0] Analog Input Channel Select
    uint8_t channelNumber_0_15;

    /// unpacked ADC_MODE_CONTROL.PM[1:0] Power Management MAX11131_PM_enum_t
    uint8_t PowerManagement_0_2;

    /// unpacked ADC_MODE_CONTROL.CHAN_ID
    uint8_t chan_id_0_1;

    /// unpacked ADC_CONFIGURATION.AVG and ADC_CONFIGURATION.NAVG[1:0] may be 0, 4, 8, 16, or 32
    uint8_t average_0_4_8_16_32;

    /// unpacked ADC_CONFIGURATION.NSCAN[1:0] may be 4, 8, 12, or 16
    uint8_t nscan_4_8_12_16;

    /// unpacked ADC_MODE_CONTROL.SWCNV
    uint8_t swcnv_0_1;

    /// unpacked CSCAN0 and CSCAN1
    int16_t enabledChannelsMask;

    /// Each channel's most recent value in LSBs.
    /// Updated by ReadAINcode function.
    /// Use VoltageOfCode function to convert LSBs to physical voltage.
    uint16_t AINcode[16];

    /// SPI master-in slave-out data.
    /// Updated by ReadAINcode function.
    /// SampleSet mode allows up to 256 channel entry selections.
    int16_t RAW_misoData16[256];

    /// reference voltage, in Volts
    double VRef;


//----------------------------------------
// Assert SPI Chip Select
// SPI chip-select for MAX11131
//
    void SPIoutputCS(int isLogicHigh);

//----------------------------------------
// SPI write 16 bits
// SPI interface to MAX11131 shift 16 bits mosiData16 into MAX11131 DIN
// ignoring MAX11131 DOUT
//
    void SPIwrite16bits(int16_t mosiData16);

//----------------------------------------
// SPI write 17-24 bits
// SPI interface to MAX11131 shift 16 bits mosiData16 into MAX11131 DIN
// followed by one additional SCLK byte.
// ignoring MAX11131 DOUT
//
    void SPIwrite24bits(int16_t mosiData16_FFFF00, int8_t mosiData8_0000FF);

//----------------------------------------
// SPI read 16 bits while MOSI (MAX11131 DIN) is 0
// SPI interface to capture 16 bits miso data from MAX11131 DOUT
//
    int16_t SPIread16bits();

//----------------------------------------
// Assert MAX11131 CNVST convert start.
// Required when using any of the InternalClock modes with SWCNV 0.
// Trigger measurement by driving CNVST/AIN14 pin low for a minimum active-low pulse duration of 5ns. (AIN14 is not available)
//
    void CNVSToutputPulseLow();

//----------------------------------------
// Wait for MAX11131 EOC pin low, indicating end of conversion.
// Required when using any of the InternalClock modes.
//
    void EOCinputWaitUntilLow();

//----------------------------------------
// Return the status of the MAX11131 EOC pin.
//
    int EOCinputValue();

private:
    // SPI object
    // global extern SPIClass SPI defined in SPI.h
    uint32_t m_SPI_SCLK_Hz;
    int m_SPI_dataMode;
    int m_SPI_cs_state;

    // Selector pin object
    uint8_t m_spi_cs_pin;

// InputPin Name = CNVST
// InputPin Description = Active-Low Conversion Start Input/Analog Input 14
// InputPin Function = Trigger
    uint8_t m_CNVST_pin;
//
// InputPin Name = REF+
// InputPin Description = External Positive Reference Input. Apply a reference voltage at REF+. Bypass to GND with a 0.47uF capacitor.
// InputPin Function = Reference
    // uint8_t m_REF_plus_pin;
//
// InputPin Name = REF-/AIN15
// InputPin Description = External Differential Reference Negative Input/Analog Input 15
// InputPin Function = Reference
    // uint8_t m_REF_minus_slash_AIN15_pin;
//
// OutputPin Name = EOC
// OutputPin Description = End of Conversion Output. Data is valid after EOC pulls low (Internal clock mode only).
// OutputPin Function = Event
    uint8_t m_EOC_pin;
//

    // Identifies which IC variant is being used
    MAX11131_ic_t m_ic_variant;

public:

    //----------------------------------------
    /// Menu item '!'
    /// Initialize device
    void Init(void);

    //----------------------------------------
    /// Menu item 'IS'
    /// ADC Channels AIN(channelId), AIN(channelId+1) = Both Single-Ended, Unipolar
    /// Full Scale = VREF
    /// Voltage per LSB count = VREF/4096
    /// AIN(channelId) is a Single-Ended input using Unipolar transfer function.
    /// AIN(channelId+1) is a Single-Ended input using Unipolar transfer function.
    /// If PDIFF_COM_1, both are Pseudo-Differential with REF- as common.
    /// AIN(channelId) voltage must always be between 0 and VREF.
    /// AIN(channelId+1) voltage must always be between 0 and VREF.
    ///
    void Reconfigure_SingleEnded(int channel_0_15);

    //----------------------------------------
    /// Menu item 'IU'
    /// ADC Channels AIN(channelId), AIN(channelId+1) = Differential Unipolar (AIN(channelId) > AIN(channelId+1))
    /// Full Scale = VREF
    /// Voltage per LSB count = VREF/4096
    /// AIN(channelId), AIN(channelId+1) are a Differential pair using Unipolar transfer function.
    /// AIN(channelId) voltage must always be between 0 and VREF.
    /// AIN(channelId+1) voltage must always be between 0 and VREF.
    ///
    void Reconfigure_DifferentialUnipolar(int channel_0_15);

    //----------------------------------------
    /// Menu item 'IB'
    /// ADC Channels AIN(channelId), AIN(channelId+1) = Differential Bipolar
    /// Full Scale = VREF
    /// Voltage per LSB count = VREF/4096
    /// AIN(channelId), AIN(channelId+1) are a Differential pair using Bipolar transfer function with range (+/-)(1/2)Vref
    /// AIN(channelId) voltage must always be between 0 and VREF.
    /// AIN(channelId+1) voltage must always be between 0 and VREF.
    ///
    void Reconfigure_DifferentialBipolarFSVref(int channel_0_15);

    //----------------------------------------
    /// Menu item 'IR'
    /// ADC Channels AIN(channelId), AIN(channelId+1) = Differential Bipolar
    /// Full Scale = 2 * VREF
    /// Voltage per LSB count = VREF/2048
    /// AIN(channelId), AIN(channelId+1) are a Differential pair using Bipolar transfer function with range (+/-)Vref
    /// AIN(channelId) voltage must always be between 0 and VREF.
    /// AIN(channelId+1) voltage must always be between 0 and VREF.
    ///
    void Reconfigure_DifferentialBipolarFS2Vref(int channel_0_15);

    //----------------------------------------
    /// SCAN_0000_NOP
    ///
    /// Shift 16 bits out of ADC, without changing configuration.
    /// Note: @return data format depends on CHAN_ID bit:
    ///     "CH[3:0] DATA[11:0]" when CHAN_ID = 1, or
    ///     "0 DATA[11:0] x x x" when CHAN_ID = 0.
    int16_t ScanRead(void);

    //----------------------------------------
    /// SCAN_0000_NOP
    ///
    /// Read raw ADC codes from device into AINcode[] and RAW_misoData16[].
    /// If internal clock mode with SWCNV=0, measurements will be triggered using CNVST pin.
    ///
    /// @pre one of the Scan functions was called, setting g_MAX11131_device.NumWords
    /// @param[in] g_MAX11131_device.NumWords: number of words to be read from the FIFO
    /// @post g_MAX11131_device.RAW_misoData16[index] contains the raw SPI Master-In,Slave-Out data
    /// @post g_MAX11131_device.AINcode[NUM_CHANNELS] contains the latest readings in LSBs
    ///
    void ReadAINcode(void);

    //----------------------------------------
    /// Sign-Extend a right-aligned MAX11131 code into a signed 2's complement value.
    /// Supports the bipolar transfer functions.
    /// @param[in] value_u12: raw 12-bit MAX11131 code (right justified).
    /// @return sign-extended 2's complement value.
    ///
    int32_t TwosComplementValue(uint32_t regValue);

    //----------------------------------------
    /// Return the physical voltage corresponding to MAX11131 code.
    /// Does not perform any offset or gain correction.
    /// @pre g_MAX11131_device.VRef = Voltage of REF input, in Volts
    /// @param[in] value_u12: raw 12-bit MAX11131 code (right justified).
    /// @param[in] channelId: AIN channel number.
    /// @return physical voltage corresponding to MAX11131 code.
    ///
    double VoltageOfCode(int16_t value_u12, int channelId);

    //----------------------------------------
    /// SCAN_0001_Manual
    ///
    /// Measure ADC channel channelNumber_0_15 once.
    /// External clock mode.
    /// @param[in] g_MAX11131_device.channelNumber_0_15: AIN Channel Number
    /// @param[in] g_MAX11131_device.PowerManagement_0_2: 0=Normal, 1=AutoShutdown, 2=AutoStandby
    /// @param[in] g_MAX11131_device.chan_id_0_1: ADC_MODE_CONTROL.CHAN_ID
    /// @return number of ScanRead() words needed to retrieve the data.
    /// @post NumWords = number of words to be read from the FIFO
    /// For external clock modes, the data format depends on CHAN_ID.
    ///     when CHAN_ID = 0: misoData16 = 0 DATA[11:0] x x x
    ///     when CHAN_ID = 1: misoData16 = CH[3:0] DATA[11:0]
    ///
    int ScanManual(void);

    //----------------------------------------
    /// SCAN_0010_Repeat
    ///
    /// Measure ADC channel channelNumber_0_15 repeatedly with averaging.
    /// Internal clock mode.
    /// @param[in] g_MAX11131_device.channelNumber_0_15: AIN Channel Number
    /// @param[in] g_MAX11131_device.average_0_4_8_16_32: Number of samples averaged per ScanRead() word.
    ///     average_0_4_8_16_32=0 to disable averaging.
    /// @param[in] g_MAX11131_device.nscan_4_8_12_16: Number of ScanRead() words to report.
    /// @param[in] g_MAX11131_device.swcnv_0_1: ADC_MODE_CONTROL.SWCNV
    ///     SWCNV=0: trigger measurement by driving CNVST pin low.
    ///         Minimum active-low pulse duration of 5ns. (AIN14 is not available)
    ///     SWCNV=1: trigger measurement on SPI CS rising edge.
    ///         CS must be held low for minimum of 17 SCLK cycles.
    ///         CNVST pin is not used. (AIN14 is available)
    /// @param[in] g_MAX11131_device.PowerManagement_0_2: 0=Normal, 1=AutoShutdown, 2=AutoStandby
    /// @return number of ScanRead() words needed to retrieve the data.
    /// @post NumWords = number of words to be read from the FIFO
    /// For internal clock modes, the data format always includes the channel address.
    ///     misoData16 = CH[3:0] DATA[11:0]
    ///
    int ScanRepeat(void);

    //----------------------------------------
    /// SCAN_0011_StandardInternalClock
    ///
    /// Measure ADC channels in sequence from AIN0 to channelNumber_0_15.
    /// Internal clock mode.
    /// @param[in] g_MAX11131_device.channelNumber_0_15: AIN Channel Number
    /// @param[in] g_MAX11131_device.average_0_4_8_16_32: Number of samples averaged per ScanRead() word.
    ///     average_0_4_8_16_32=0 to disable averaging.
    /// @param[in] g_MAX11131_device.PowerManagement_0_2: 0=Normal, 1=AutoShutdown, 2=AutoStandby
    /// @param[in] g_MAX11131_device.swcnv_0_1: ADC_MODE_CONTROL.SWCNV
    ///     SWCNV=0: trigger measurement by driving CNVST pin low.
    ///         Minimum active-low pulse duration of 5ns. (AIN14 is not available)
    ///     SWCNV=1: trigger measurement on SPI CS rising edge.
    ///         CS must be held low for minimum of 17 SCLK cycles.
    ///         CNVST pin is not used. (AIN14 is available)
    /// @return number of ScanRead() words needed to retrieve the data.
    /// @post NumWords = number of words to be read from the FIFO
    /// For internal clock modes, the data format always includes the channel address.
    ///     misoData16 = CH[3:0] DATA[11:0]
    ///
    int ScanStandardInternalClock(void);

    //----------------------------------------
    /// SCAN_0100_StandardExternalClock
    ///
    /// Measure ADC channels in sequence from AIN0 to channelNumber_0_15.
    /// External clock mode.
    /// @param[in] g_MAX11131_device.channelNumber_0_15: AIN Channel Number
    /// @param[in] g_MAX11131_device.PowerManagement_0_2: 0=Normal, 1=AutoShutdown, 2=AutoStandby
    /// @param[in] g_MAX11131_device.chan_id_0_1: ADC_MODE_CONTROL.CHAN_ID
    /// @return number of ScanRead() words needed to retrieve the data.
    /// @post NumWords = number of words to be read from the FIFO
    /// For external clock modes, the data format depends on CHAN_ID.
    ///     when CHAN_ID = 0: misoData16 = 0 DATA[11:0] x x x
    ///     when CHAN_ID = 1: misoData16 = CH[3:0] DATA[11:0]
    ///
    int ScanStandardExternalClock(void);

    //----------------------------------------
    /// SCAN_0101_UpperInternalClock
    ///
    /// Measure ADC channels in sequence from channelNumber_0_15 to AIN15.
    /// Internal clock mode.
    /// @param[in] g_MAX11131_device.channelNumber_0_15: AIN Channel Number
    /// @param[in] g_MAX11131_device.average_0_4_8_16_32: Number of samples averaged per ScanRead() word.
    ///     average_0_4_8_16_32=0 to disable averaging.
    /// @param[in] g_MAX11131_device.PowerManagement_0_2: 0=Normal, 1=AutoShutdown, 2=AutoStandby
    /// @param[in] g_MAX11131_device.swcnv_0_1: ADC_MODE_CONTROL.SWCNV
    ///     SWCNV=0: trigger measurement by driving CNVST pin low.
    ///         Minimum active-low pulse duration of 5ns. (AIN14 is not available)
    ///     SWCNV=1: trigger measurement on SPI CS rising edge.
    ///         CS must be held low for minimum of 17 SCLK cycles.
    ///         CNVST pin is not used. (AIN14 is available)
    /// @return number of ScanRead() words needed to retrieve the data.
    /// @post NumWords = number of words to be read from the FIFO
    /// For internal clock modes, the data format always includes the channel address.
    ///     misoData16 = CH[3:0] DATA[11:0]
    ///
    int ScanUpperInternalClock(void);

    //----------------------------------------
    /// SCAN_0110_UpperExternalClock
    ///
    /// Measure ADC channels in sequence from channelNumber_0_15 to AIN15.
    /// External clock mode.
    /// @param[in] g_MAX11131_device.channelNumber_0_15: AIN Channel Number
    /// @param[in] g_MAX11131_device.PowerManagement_0_2: 0=Normal, 1=AutoShutdown, 2=AutoStandby
    /// @param[in] g_MAX11131_device.chan_id_0_1: ADC_MODE_CONTROL.CHAN_ID
    /// @return number of ScanRead() words needed to retrieve the data.
    /// @post NumWords = number of words to be read from the FIFO
    /// For external clock modes, the data format depends on CHAN_ID.
    ///     when CHAN_ID = 0: misoData16 = 0 DATA[11:0] x x x
    ///     when CHAN_ID = 1: misoData16 = CH[3:0] DATA[11:0]
    ///
    int ScanUpperExternalClock(void);

    //----------------------------------------
    /// SCAN_0111_CustomInternalClock
    ///
    /// Measure selected ADC channels in sequence from AIN0 to AIN15,
    ///     using only the channels enabled by enabledChannelsMask.
    ///     Bit 0x0001 enables AIN0.
    ///     Bit 0x0002 enables AIN1.
    ///     Bit 0x0004 enables AIN2.
    ///     Bit 0x0008 enables AIN3.
    ///     Bit 0x0010 enables AIN4.
    ///     Bit 0x0020 enables AIN5.
    ///     Bit 0x0040 enables AIN6.
    ///     Bit 0x0080 enables AIN7.
    ///     Bit 0x0100 enables AIN8.
    ///     Bit 0x0200 enables AIN9.
    ///     Bit 0x0400 enables AIN10.
    ///     Bit 0x0800 enables AIN11.
    ///     Bit 0x1000 enables AIN12.
    ///     Bit 0x2000 enables AIN13.
    ///     Bit 0x4000 enables AIN14.
    ///     Bit 0x8000 enables AIN15.
    /// Internal clock mode.
    /// @param[in] g_MAX11131_device.enabledChannelsMask: Bitmap of AIN Channels to scan.
    /// @param[in] g_MAX11131_device.average_0_4_8_16_32: Number of samples averaged per ScanRead() word.
    ///     average_0_4_8_16_32=0 to disable averaging.
    /// @param[in] g_MAX11131_device.PowerManagement_0_2: 0=Normal, 1=AutoShutdown, 2=AutoStandby
    /// @param[in] g_MAX11131_device.swcnv_0_1: ADC_MODE_CONTROL.SWCNV
    ///     SWCNV=0: trigger measurement by driving CNVST pin low.
    ///         Minimum active-low pulse duration of 5ns. (AIN14 is not available)
    ///     SWCNV=1: trigger measurement on SPI CS rising edge.
    ///         CS must be held low for minimum of 17 SCLK cycles.
    ///         CNVST pin is not used. (AIN14 is available)
    /// @return number of ScanRead() words needed to retrieve the data.
    /// @post NumWords = number of words to be read from the FIFO
    /// For internal clock modes, the data format always includes the channel address.
    ///     misoData16 = CH[3:0] DATA[11:0]
    ///
    int ScanCustomInternalClock(void);

    //----------------------------------------
    /// SCAN_1000_CustomExternalClock
    ///
    /// Measure selected ADC channels in sequence from AIN0 to AIN15,
    ///     using only the channels enabled by enabledChannelsMask.
    ///     Bit 0x0001 enables AIN0.
    ///     Bit 0x0002 enables AIN1.
    ///     Bit 0x0004 enables AIN2.
    ///     Bit 0x0008 enables AIN3.
    ///     Bit 0x0010 enables AIN4.
    ///     Bit 0x0020 enables AIN5.
    ///     Bit 0x0040 enables AIN6.
    ///     Bit 0x0080 enables AIN7.
    ///     Bit 0x0100 enables AIN8.
    ///     Bit 0x0200 enables AIN9.
    ///     Bit 0x0400 enables AIN10.
    ///     Bit 0x0800 enables AIN11.
    ///     Bit 0x1000 enables AIN12.
    ///     Bit 0x2000 enables AIN13.
    ///     Bit 0x4000 enables AIN14.
    ///     Bit 0x8000 enables AIN15.
    /// External clock mode.
    /// @param[in] g_MAX11131_device.enabledChannelsMask: Bitmap of AIN Channels to scan.
    /// @param[in] g_MAX11131_device.PowerManagement_0_2: 0=Normal, 1=AutoShutdown, 2=AutoStandby
    /// @param[in] g_MAX11131_device.chan_id_0_1: ADC_MODE_CONTROL.CHAN_ID
    /// @return number of ScanRead() words needed to retrieve the data.
    /// @post NumWords = number of words to be read from the FIFO
    /// For external clock modes, the data format depends on CHAN_ID.
    ///     when CHAN_ID = 0: misoData16 = 0 DATA[11:0] x x x
    ///     when CHAN_ID = 1: misoData16 = CH[3:0] DATA[11:0]
    ///
    int ScanCustomExternalClock(void);

    //----------------------------------------
    /// SCAN_1001_SampleSetExternalClock
    ///
    /// Measure ADC channels in an arbitrary pattern.
    ///     Channels can be visited in any order, with repetition allowed.
    /// External clock mode.
    /// @pre g_MAX11131_device.enabledChannelsPatternLength_1_256: number of channel selections
    /// @pre g_MAX11131_device.enabledChannelsPattern: array containing channel selection pattern
    ///     In the array, one channel select per byte.
    ///     In the SPI interface, immediately after SAMPLESET register is written,
    ///     each byte encodes two channelNumber selections.
    ///     The high 4 bits encode the first channelNumber.
    ///     (((enabledChannelsPattern[0]) & 0x0F) << 4) | ((enabledChannelsPattern[1]) & 0x0F)
    ///     If it is an odd number of channels, additional nybbles will be ignored.
    ///     CS will be asserted low during the entire SAMPLESET pattern selection.
    /// @param[in] g_MAX11131_device.enabledChannelsPattern: array of channel select, one channel per byte
    /// @param[in] g_MAX11131_device.PowerManagement_0_2: 0=Normal, 1=AutoShutdown, 2=AutoStandby
    /// @param[in] g_MAX11131_device.chan_id_0_1: ADC_MODE_CONTROL.CHAN_ID
    /// @return number of ScanRead() words needed to retrieve the data.
    /// @post NumWords = number of words to be read from the FIFO
    /// For external clock modes, the data format depends on CHAN_ID.
    ///     when CHAN_ID = 0: misoData16 = 0 DATA[11:0] x x x
    ///     when CHAN_ID = 1: misoData16 = CH[3:0] DATA[11:0]
    ///
    int ScanSampleSetExternalClock(void);

    //----------------------------------------
    /// Example configure and perform some measurements in ScanManual mode.
    /// @param[out] pd_mean = address for double mean (avearge)
    /// @param[out] pd_variance = address for double variance (variance)
    /// @param[out] pd_stddev = address for double stddev (standard deviation)
    /// @param[out] pd_Sx = address for double Sx (sum of all X)
    /// @param[out] pd_Sxx = address for double Sxx (sum of squares of each X)
    void Example_ScanManual(int channelNumber_0_15, int nWords, 
  double* pd_mean, double* pd_variance, double* pd_stddev, 
  double* pd_Sx, double* pd_Sxx);

}; // end of class MAX11131

#endif // __MAX11131_H__

// End of file
